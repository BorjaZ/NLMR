---
title: "Basic Usage of NLMR"
author: "Marco Sciaini & Craig E.Simpkins"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: Citations.bib
vignette: >
  %\VignetteIndexEntry{Basic Usage of nlmR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

`NLMR` is a `R` package designed to generate neutral landscape models (NLMs), simulated landscapes used to explore landscape scale ecological patterns and processes. The `NLMR` package was designed with a similar philosophy to the Python package `NLMpy` [see @EtheringtonNLMR2015], offering a general numeric framework allowing for a high degree of flexibility. Most of the common NLMs, as described by the relevant literature, can be produced using NLMR. Additionally, NLMR allows users to blend multiple landscapes, classify landscape elements categorically and measure basic landscape level metrics. All NLMs produced take the form of two-dimensional raster arrays with specified row and column dimensions and cell values ranging between 0 and 1. By returning raster arrays, NLMs are easily integrated into the workflow of many useful spatial analysis packages, notably the `raster` package

## Basic landscape generation

`NLMR` supplies 12 NLM algorithms. The algorithms differ from each other in spatial auto-correlation, from no auto-correlation (random NLM) to a constant gradient (planar gradients) [see @Palmer1992].  

The 12 NLM algorithms are:  

1. distance gradient
1. edge gradient  
1. midpoint displacement  
1. planar gradient  
1. random  
1. random cluster nearest-neighbour 
1. random element 
1. random percolation  
1. random rectangular cluster 
1. spatially correlated random fields (Gaussian random fields)  
1. two-dimensional fractional Brownian motion  
1. random mosaic fields

The basic syntax used to produce a NLM landscape is:
```
nlm_modeltype(nCol, nRow, resolution, ...)
```
    
For example, to produce a simple random neutral landscape one could use the following code:

```{r, fig.height=7, fig.width=7, fig.align='center'}
 x <- NLMR::nlm_random(20,20)
 NLMR::util_plot(x)
```



## Blending landscapes

Multiple NLM rasters can be blended or merged together to create new landscape patterns. A single primary or base raster can be blended with any number of additional secondary rasters, with optional scaling factors used to control the influence of the secondary rasters.  

The `util_merge` function is used to blend the rasters as in the example below:

```{r, fig.height=7, fig.width=7, fig.align='center'}
  #Create primary landscape raster
  pL <- NLMR::nlm_edgegradient(nCol = 100, nRow = 100)

  NLMR::util_plot(pL)

  #Create secondary landscape rasters
  sL1 <- NLMR::nlm_distancegradient(nCol = 100, nRow = 100, origin = c(10, 10, 10, 10))
  sL2 <- NLMR::nlm_random(nCol = 100, nRow = 100)

  mL1 <- NLMR::util_merge(pL, c(sL1, sL2), scalingfactor = 1)
  
  NLMR::util_plot(mL1)
```

## Classifying categories

Landscape rasters generated by `NLMR` contain continuous values between 0 and 1, though these can be converted into categorical values using `util_classify`. The number of classes and the proportion of the NLM raster assigned to each class is determined using a `weighting` vector. If the weighting vector does not sum to 1, the sum of the weightings is divided by the number of vector elements and these are used to define the class proportions. By default classes are numerical starting from 1. If non-numerical levels are required, `level_names` can be specified. These classes can be plotted by selecting `discrete = TRUE` in `util_plot`. The number of cells contained by each class can be calculated using `metric_area`.

```{r fig.height=7, fig.width=7, fig.align='center'}
nr <- NLMR::nlm_randomcluster(50, 50, neighbourhood = 4, p = 0.5)
weighting <- c(0.5, 0.25, 0.25)
cr <- NLMR::util_classify(nr, weighting = weighting, level_names = c("L1", "L2", "L3"))
NLMR::util_plot(cr, discrete = TRUE)
NLMR::metric_area(cr)
```

## Handling Raster* Objects in R

## Visualizing neutral landscape models

### Contour plot
```{r , fig.height=7, fig.width=7, message=FALSE, warning=FALSE, fig.align='center'}
library("rasterVis")
pL <- NLMR::nlm_mpd(nCol = 50, nRow = 50, roughness = 0.6)


contourplot(pL)

levelplot(pL,
          contour = TRUE,
          pretty = TRUE)
```

### 3D Graphs

#### Static plot
```{r , fig.height=7, fig.width=7, message=FALSE, warning=FALSE, fig.align='center'}
library("raster")
pL <- NLMR::nlm_fBm(nCol = 50, nRow = 50, H = 0.6)

persp(pL,
      exp=0.5,
      maxpixels = 5000,
      theta = 125, 
      phi=45, 
      xlab="Longitude", 
      ylab="Latitude", 
      zlab="Z", 
      shade = 0.45)

```


#### Interactive Plot
```{r , fig.height=7, fig.width=7, message=FALSE, warning=FALSE, fig.align='center'}
library("rgl")
library("rasterVis")
library("viridis")
pL <- NLMR::nlm_mpd(nCol = 100, nRow = 100, roughness = 0.6)

plot3D(pL,
       zfac=2,
       lit=FALSE,
       col=colorRampPalette(magma(11)))

rglwidget()
       
```


### Interactive Graphs

```{r message=FALSE, warning=FALSE}
library(highcharter)
library(magrittr)
library(plotly)

# create a NLM to work with
pL <- NLMR::nlm_mosaicfield(nCol = 100, nRow = 100, n = 20)

# coerce to matrix
pL_matrix <- raster::as.matrix(pL)

# plot interactive graph
hchart(pL_matrix) %>% 
  # changing default color
  hc_colorAxis(stops = color_stops(colors = viridis::inferno(10)))
  
# With plotly we can combine the interactive approach with the 3D Visualization
plot_ly(z = as.matrix(pL_matrix), type = "surface", colors = viridis::magma(8))
```

### RasterStacks/Bricks

```{r message=FALSE, warning=FALSE}
library(rasterVis)

# create a NLM to work with
pL <- NLMR::nlm_mosaicfield(nCol = 100, nRow = 100, n = 20, collect = TRUE)

# user rasterVis::levelplot to plot brick
levelplot(pL$steps)

```


##References
